
### Layered Architecture 와 Hexagonal Architecture 의 차이 
#### 레이어드 아키텍처
- 각 구성요소들이 '관심사의 분리' 를 달성하기 위해 책임을 가진 계층으로 분리한 아키텍처
		- 관심사의 분리를 하는이유
		- Clean Architeture 에서도 나오는데 소프트웨어 개발 설계를 함에 있어서 응집도는 높이고 결합도는 낮게 설계하기 위함.
		- 이를 통해 재사용성과 유지보수성을 높임 

- 한 계층에서 자신의 책임외의 행위는 하위 계층에 의존적인 구조이다. 
- 그러나 하위계층은 상위 계층에 대한 어떤 지식이나 정보가 없어야 한다. 

4-tier Layered Architecture
- Presentation Layer
- Business Layer
- Persistence Layer
- Database Layer

#### Hexagonal Architecture
- 포트와 어댑터 아키턱처는 인터페이스나 기반 요소(InfraStructure) 의 변경에 영향을 받지 않는 핵심 코드를 만들고 이를 견고하게 관리하는 것이 목표. 
- 포트는 바로 인터페이스 입니다. 예를 들면 클래스의 메서드 시그니처나 Java 의 인터페이스가 바로 포트라고 할 수 있습니다. 
- 어댑터는 디자인 패턴데이도 있듯이 클라이언트에 제공해야 할 인터페이스를 따르면서도 내부 구현은 서버의 인터페이스로 위임하는 것 
![[Pasted image 20231009001303.png]
![[Pasted image 20231008160257.png]]
먼저 어댑터가 애플리케이션과는 겹치지 않고 포트와 겹쳐있는 모습으로 미루어 보아 어댑터가 애플리케이션을 직접 참조하지 않고 포트에 의존하고 있다는 것을 알 수 있다 .
여기서 포트는 변경이 잦은 어댑터와 애플리케이션의 결합도를 낮추는 역할을 합니다. 

애플리케이션은 핵심 로직에 가까우므로 결합도를 낮추는 것이 매우 중요합니다.
또한 애플리케이션은 도메인에 의존하지만 도메인은 애플리케이션과 어댑터에 전혀 의존하지 않습니다. 
따라서 애플리케이션이나 어댑터가 변경되어도 핵심 로직인 도메인은 아무런 영향을 받지 않습니다.

또한 이렇게 포트라는 인터페이스를 많이 활용해서 개발하게 되면 테스트 코드를 만들때 Mock 객체같은 것을 많이 활용할 수 있어서 테스트 하기에도 좀더 수월해진다.

### 객체 관계형 임피던스 불일치란?
객체 관계형 임피던스 불일치는 객체 지향 코드베이스가 관계형 데이터베이스와 데이터를 교환할때 발생합니다.  데이터가 모델링되는 방식에는 근본적인 차이가 있습니다. 

RDBMS 는 보통 데이터를 가져올때 spread sheet 의 테이블 형태로 가져오지만 java 같은 객체지향의 Class 는 객체간의 그래프로 데이터를 가져온다,.

다시 말해서 객체지향에서 사용하는 모든 Class 가 RDBMS 의 테이블과  1:1 매핑되지도 않고, Class 는 또 다른 Class 를 멤버 변수로도 가질 수 있고, 또 상속해서 사용할수도 있기에 이러한 점에서 데이터 교환 이슈가 있다. 

이런 이슈 때문에 ORM 이 등장했지만 그럼에도 불구하고 OLAP 같은 SELCT 를 할 떄는 SQL 이 더 효율적이만, 제가 SQL 과 ORM 의 성능을 제대로 비교하고 저하 원인도 파악하는 글을 썻었는데,

전반적으로는 SQL 이 좋지만, 특정 상황에서는 ORM 이 더 효율적일 수도 있다를 알게 되었습니다.



<br/><br/>
### DDD (Domain Driven Development)
도메인을 중심으로 설계해 나가는 방법

도메인이란 소프트웨어로 해결해야할 문제의 영역입니다.
소프트웨어의 본질은 해당 소프트웨어의 사용자를 위해 도메인에 관련된 문제를 해결하는 능력.

아무리 기술적으로 정교하고 뛰어난 성능을 갖추더라도 당면한 문제를 해결하지 못하는 소프트웨어는 실패한 소프트웨어라고 할 수 있습니다. 얼마나 빠른가, 얼마나 많이 처리할 수 있나, 얼마나 많은 사람이 붙어서 사용할 수 있나 등은 나중 이야기 입니다.

기존 개발의 문제점 (비즈니스 로직의 위치)
- 데이터베이스 위주의 개발 (데이터베이스 모델링을 중시) - 
	- 서비스에는 흐름제어 로직밖에 없고, 비즈니스 규칙과 개념들은 SQL 에 존재한다.  이렇게 비즈니스 로직과 저장 기술이 강하게 결합되어 있는 구조인 경우, 저장소를 변경하기 쉽지 않다. 또한 성능 측면에서 성능을 데이터베이스에 의존하게 된다. 이러면 데이터가 많아졌을때 데이터베이스의 성능은 지속적으로 떨어지고, 이를 최적화 하기 위해 데이터베이스 서버의 사양과 용량을 계속 증가시키고 쿼리 튜닝에 몰두 할 수 밖에 없다.
	- 클라우드 인프라를 사용한 자동 스케일 아웃은 의미가 없어진다.
	- 정작 바쁜것은 데이터베이스이기 때문에 애플리케이션을 아무리 스케일 아웃 해봐야 효과는 미미하다.

- 트랜잭션 스크립트 패턴
	- 서비스 (Spring 에서 사용되는 Service) 에 모든 비즈니스 로직이 있고 비즈니스 절차에 따라 도메인 객체를 이용해 처리한다.
	- 도메인 객체는 단지 속성값만 이용되는 정보 묶음의 역할만 하게 된다. 서비스는 유스케이스 처리의 단위로 대부분의 비즈니스 로직 처리가 서비스에서 이뤄지므로 비슷한 유스케이스의 경우 서비스에 중복되는 코드가 계속 생겨날 수 있고 이러한 점이 유지보수를 어렵게 한다.
	- 비즈니스 로직을 테스트하기 위해 Mocking 을 해야하고 이는 테스트의 복잡성을 높이고 관리하기 어려운 테스트 코드를 발생시킨다. 

#### 그럼 비즈니스 로직은 어디에 있는 것이 좋을까요?
##### 도메인 모델 패턴
- 도메인 객체가 속성뿐만 아니라 비즈니스 행위를 가지고 있어 책임을 수행하게 된다.
- 서비스의 책임들이 도메인으로 분산되기 때문에 서비스의 메서드는 단순해진다.
- 거대한 서비스 클래스 대신 적절한 책임을 가진 여러 클래스로 구성되므로 이해하기 쉽고 관리 및 테스트가 쉽다.
- 잘 정의된 도메인 모델은 코드양을 줄이고 재사용성고 높다. 
- 도메인 모델 패턴은 도메인 주도 설계의 애그리게이트 패턴을 적용할 수 있는 구조이다. 

##### 도메인 주도 설계
- 도메인 주도 설계는 크게 전략적 설계와 전술적 설계로 나뉜다.
- 전략적 설계
	- 도메인 전문가 및 기술팀이 함께 모여 유비쿼터스 언어를 통해 도메인 지식을 공유 및 이해하고 이를 기준으로 개념과 경계를 식별해 바운디드 컨텍스트로 정의하고 경계의 관계를 컨텍스트 맵으로 정의하는 활동 
- 전술적 설계
	- 전략적 섥에서 도출된 바운디드 컨텍스트와 도메인을 이용하여 애그리게이트 패턴, 엔티티와 값 
	- 객체, 레포지토리 등을 구성하고 구현하는 활동 
	
### 전략적 설계
도메인과 서브 도메인
- 도메인으 한 조직이 행하는 일과 그 조직 안의 세계를 의미합니다.
- 서브 도메인은 어떤 도메인 영역의 상위 도메인에 있는 것을 강조하기 위해 사용하는 용어입니다.
- 서브 도메인은 중요도에 따라 핵심 , 지원, , 일반 도메인으로 나눕니다.
- 핵심 도메인
	- 다른 경쟁자와 차별화를 만들 비즈니스 영역이기 때문에 기업의 프로젝트 목록에서 높은 우선순위를 갖는 영역이자, 소프트우어 개발에서 전략적으로 가장 큰 투자가 필요한 영역 (주문,결제)
- 지원 도메인
	- 비즈니스에 필수적이지만 핵심은 아닌 부분 그러나 핵심 도메인을 성공시키기 위해서는 반드시 필요한 여역 (카탈로그 ,쿠폰)
-  일반 도메인 
	- 비즈니스적으로 특화된 부분은 아니지만 전체 비즈니스 솔루션에는 필요한 부분으로 기존 제품을 구매해 대체할 수 있다. (인증 관리)


##### 바운디드 컨텍스트
- 도메인 영역의 경계
- 바운디드 컨텍스트 안에서는 유비쿼터스 언어를 사용해야 한다
- 도메인 영역의 경계의 기준은 유비쿼터스 언어를 사용했을 때, 해당 용어의 개념이 달라지는 그 곳을 기준으로 경계를 나눈다 
- ![[Pasted image 20231008162757.png]]
- 고객이라는 도메인은 결제 도메인 입장에서는 신용카드 정보나 계좌정보를 가진 결제자로서 사용되고 배송 도메인 입장에서는 상품을 받을 주소와 우편번호 전화번호를 소유한 수취자를 의미한다. 
- 도메인 모델은 특정한 컨텍스트 안에서 완전한 의미를 갖는다
- 바운디드 컨텍스트는 여러개의 서브 도메인으로 구성되고 하나의 서브 도메인은 한 바운디드 컨텍스트에 포함된다. 


### 전술적 설계
도메인 모델링 구성 요소
- 기존 객체 모델링의 자유도가 높아 문제 영역을 파고들수록 여러 층의 복잡한 계층 구조를 만들게 될 가능성이 높다. 전술적 설계에서는 도메인 모델링 구성 요소의 역할에 따른 유형을 정의하고 이러한 규칙에 따라 모델링하면 단순하게 설계가 가능하디

- 엔티티
	- 다른 엔티티와 구별할 수 있는 식별자를 가진 도메인의 실체 개념을 표현하는 객체
	- 식별자는 고유하되 엔티티의 속성 및 상태는 계속 변할 수 있다.
	- 식별자가 있기 때문에 데이터베이스로 추적 가능하다 
- 값 객체
	- 도메인 내의 어떤 대상을 측정하고, 수량화 하고, 설명한다
	- 관련 특징을 모은 필수 단위로 개념적 전체를 모델링 한다
	- 측정이나 설명이 변경될 땐 완벽히 대체 가능하다
	- 다른 값과 등가성을 사용해 비교할 수 있다
	- 값 객체는 일단 생성되면 변경할 수없어 (immutable)
- 애그리게이트
	- 관련 객체를 하나로 묶은 군집(1~2 개의 엔티티와 값객체)
	- 애그리게이트는 군집에 속한 객체들을 관리하는 루트 엔티티를 갖는다
	- 이들 간에는 비즈니스 의존관계를 맺고 있으며 비즈니스 정합성을 맞출 필요가 있다. 따라서 애그리게이트 단위가 트랜잭션 기본 단위가 된다 
	- 애그게이로 묶어서 보면 좀 더 상위 수준에서 도메인 모델 간의 관계를 파악할 수있다
	- 애그리게이트는 응집력을 유지하고 애그리트간에는 느슨한 결합을 유지한다
	- 애그리게이트에 속한 객체는 유사하거나 동일한 라이프사이클을 갖는다
	- 한 애그리게이트에 속한 객체는 다른 애그리게이트에 속하지 않는다
	![[Pasted image 20231008163754.png]]
- 애그리게이트 루트 
	- 애그리게이트 내에 있는 엔티티 중 가장 상위에 있는 엔티티를 애그리게이트 루트로 정함
	- 애그리게이트 루트를 통해서만 애그리게이트 내의 엔티티 값 객체를 변경할 수 있다.(퍼사드 패턴과 유사)
	- 애그리게이트 간의 참조는 직접참조하지 않고 ID 참조를 한다 (그림에서 Order 가 Buyer 를 직접 참조하지 않고 BuyierId 로 참조)
	- 애그리게이트는 단일 트랜잭션으로 일관성을 유지하지만 애그리게이트간의  일관성이 필요하다면 도메인 이벤트를 통해 애그리게이트를 갱신해서 일관성을 유지한다.

- 레포지토리
	- 엔티티나 밸류 요구사항에서 도출되는 도메인 모델이라면 리포지토리는 구현을 위한 도메인 모델
	- 애그리게이트 단위로 도메인 객체를 저장하고 조회하는 기능을 정의한다
	- 애그리게이트를 구하는 리포지토리 메서드는 완전한 애그리게이트를 제공해야한다
	- 리포지터리가 완전한 애그리게이트를 제공하지 않으면, 필드나 값이 올바르지 않아 애그리 게이트의 기능을 실행하는 도중에 문제가 발생한다.
	- 레포지토리는 애그리거트(루트) 단위로 존재하며 테이블 단위로 존재하는 것이 아니다 (애그리게이트 1개당 리포지토리 1개)
- 도메인 서비스
- 팩토리
- 도메인 이벤트 

### 도메인 주도 설계 아키텍처
기존 레이어드 아키텍처의 문제점
![[Pasted image 20231008165234.png]]
- 도메인 레이어가 인프라 레이어에 의존하고 있다.
- 이는 고수준 모듈이 저수준 모듈에 의존하는 것이다
- 고수준 모듈: 어떤 의미 있는 단일 기준을 제공하는 모듈
- 저수준 모듈: 고순줄 모듈의 기능을 구현하기 위해 필요한 하위 기능의 실제 구현
- **도메인 주도 설계에서 비즈니스 로직을 담당하는 도메인 레이어가 고수준 모듈** 
**- 우리는 이 도메인 레이어를 보호애햐할 필요가 있다**

**DIP (Dependency Inversion Principal) 의존 역전 원칙**
![[Pasted image 20231008165422.png]]
	- 저수준 모듈이 고수준 모듈에 의존한다고 해서 이를 DIP 라 부른다
	- 인프라스트럭쳐 영역에 의존할 때 발생했었던 구현 교체가 어렵다는 문제와 테스트가 어려운 문제를 해소 할 수 있다. 
	- 고수준 모듈은 더 이상 자수준 모듈에 의존하지 않고 구현을 추상화한 인터페이스에 의존한다.
	- DIP 를 적용할 때 하위 기능을 추상화한 인터페이스는 고수준 모듈 관점에서 도출한다
	- 추상화한 인터페이스는 저수준 모듈이 아닌 고수준 모듈에 위치한다.
![[Pasted image 20231008165647.png]]
![[Pasted image 20231008165651.png]]
<br/><br/>
### CQRS  사례 


<br/><br/>
### MVVM 패턴이란?
MVC 패턴에서 Controller 를 뺴고 ViewModel 을 추가한 패턴입니다.
- View
	- ios 는 ViewController 까지 View 가 됩니다
	- 사용자가 보여지는 View 를 생각하면된다, 유저 인터랙션을 받는 역할, 인터랙션을 받을 시 ViewModel 에게 명령을 내립니다
- ViewModel
	- View 를 표현하기 위해 만들어진 View 를 위한 Model
	- View 와는 Binding 을 하여 연결 후 View 에게서 액션을 받고 또한 View 를 업데이트한다 
- Model
	- 데이터, 비즈니스 로직,  서비스 클라이언트 등으록 구성
	- 실제 데이터 

[장점]
- View 와 Model 이 서로 전혀 알지 못하기에 독립성을 유지할 수 있다
- 독립성을 유지하기 떄문에 효율적인 테스트 코드 작성이 가능
- View 와 ViewModel 을 바인딩하기 때문에 코드의 양이 줄어든다 
- View 와 ViewModel 은 n:1 관계이다

[단점]
- 간단한 UI 에서 오히려 ViewModel 을 생성해야 하는 복잡도 증가
- 데이터 바인딩이 필수적으로 요구 
- 복잡해질수록 Controller 처럼 ViewModel 이 방대해짐
- 표준화된 틀이 존재하지 않아 사람마다 이해도가 다를수 있음 

<br/><br/>
### 병렬처리 경험
##### 병렬처리를 사용하기 좋은예 
1. 애플리케이션이 I/O 작업을 처리할떄는 보통 운영체제가 Stream 을 처리해서 결과를 돌려줄때까지 계속 대기하는데, 이 시간 동안 애플리케이션이 멈춰 있을 경우 

2. 애플리케이션이 CPU 를 사용하여 계산할떄 여러 CPU 중 하나만 사용하고 다른 CPU 는 유휴상태에 있는 경우 

##### 쓰레드와 프로세스 차이 
멀티 쓰레딩과 멀티프로세싱은 컴퓨터 프로그램에서 동시성을 달성하는 2가지 서로 다른 접근 방식입니다.

정의:
- 멀티스레딩:
	- 멀티스레딩에서는 단일 프로세스가 동일한 주소 공간내에서 여러 실행 스레드를 생성합니다. 
	- 스레드는 프로세스와 동일한 메모리와 리소스를 공유합니다.
	
- 멀티 프로세싱:
	- 여러개의 독립적인 프로세스가 별도의 메모리 공간에서 실행됩니다. 각 프로세스는 자체 리소스와 메모리가 있으며 IPC(프로세스 간 통신) 메커니즘을 통해 통신합니다. 

자원 사용량
- 멀티 쓰레딩:
	- 동일한 프로세스 내의 쓰레드는 동일한 메모리 공간을 공유하므로 쓰레드 간 통신을 보다 효율적으로 만들 수 있습니다. 그러나 제대로 관리하지 않으면 데이터 경합 및 교착 상태와 같은 문제가 발생할 수 있다
- 멀티 프로세싱:
	- 각 프로세스는 자체 메모리 공간을 사용하여 독립적으로 실행됩니다. 이러한 분리는 데이터 격리를 보장하지만 프로세스 간 통신은 더 복잡하고 리소스 집약적일 수 있습니다.

동시성 대 병렬성
- 멀티 쓰레딩:
	- 스레드는 동시에 실행됩니다. 즉 동일한 CPU 코어를 공유하고 교대로 명령을 실행합니다.
	- 이는 I/O 바인딩된 작업에 대한 응답성과 효율성을 향상 시킬수 있지만 CPU 바인딩된 작업에 대해 여러 CPU 코어를 완전히 활용하지 않는다

- 멅티 프로세싱:
	- 여러 CPU 코어를 효과적으로 활용하여 프로세스를 병렬적으로 실행할 수 있습니다. 이는 CPU 바인딩된 작업에 적합하지만 별도의 메모리 공간이 필요하기 때문에 더 많은 오버헤드가 발생할 수 있습니다.

내 결합성
- 멀티 쓰레딩:
	- 오류로 인해 하나의 쓰레드가 충돌하면 잠재적으로 전체 프로세스가 충돌하여 모든 쓰레드에 영향을 미칠 수 있습니다.

- 멀티 프로세싱"
	- 하나의 프로세스가 충돌하더라도 독립적으로 실행되므로 일반적으로 다른 프로세스에 영향을 주지 않습니다. 이는 더 나은 결함 격리를 제공합니다.


복잡성
- 멀티 쓰레딩:
	- 스레드가 동일한 메모리 공간을 공유하므로 데이터 공유가 더 쉬워지므로 멀티스레딩 프로그램 구현이 덜 복잡해질 수 있습니다.
	
- 멀티 프로세싱:
	- 개별 프로세스 간의 프로세스 간 통신 및 동기화를 관리하는 것이 더 복잡할 수 있습니다.

확장성
- 멀티 쓰레딩:
	- 쓰레드가 동일한 리소스를 공유하므로, 사용 가능한 CPU 코어 수에 따라 확장이 제한될 수 있습니다.

- 멀티 프로세싱"
	- 여러 CPU 코어를 활용할 수 있는 보다 독리적인 프로세스를 시작하여 확장할 수 있으므로 확장성이 더 좋은 경우가 많습니다.


결과적으로 파이썬에는 GIL (Globla Interpreter lock) 이 존재해서 멀티 쓰레드에 비효율적인 면이 있지만, 그럼에도 불구하고 제가 개선하려는 I/O 작업 처리에서는 멀티 프로세싱 보다 멀티 쓰레드가 더 효율적이었다. 

그리고 DB Session 같은 것을 물고 있는 함수는 멀티 쓰레드나 프로세스에 상관없이 모두 정상적으로 동작하지 않을 확률이 매우 크다.


### 스케줄러
프로세스를 스케줄링하기 위한 Queue 는 3가지 종류가 존재한다

- Job Queue : 현재 시스템 내에 있는 모든 프로세스의 집합
- Ready Queue: 현재 메모리 내에 있으면서 CPU 를 잡아서 실행되기를 기다리는 프로세스의 집합 
- Device Queue:  Device I/O 작업을 대기하고 있는 프로세스의 집합 

각각의 Queue 에 프로세스들을 넣고 뺴주는 스케줄러에도 크게 3가지 종류가 존재한다

#### 장기 스케줄러
메모리는 한정되어 있는데 많은 프로세스 들이 한꺼번에 메모리에 올라갈 경우, 대용량 메모리에 임시로 저장된다. 이 Pool 에 저장되어 있는 프로세스 중 어떤 프로세스에 메모리를 할당하여 ready queue 로 보낼지 결정하는 역할을 한다

- 메모리와 디스크 사이의 스케줄링을 담당
- 프로세스와 Memory 를 할당
- degree of Multiprocessing 제어 (실핼중인 프로세스의 수 제어)
- 프로세스의 상태  (new -> ready)

** 장기 스케줄러는 결과적으로 Disk 를 건드리게 떄문에 메모리에 프로그램이 너무 많아도 너무 적어도 성능이 좋지 않은 것이다.

#### 단기 스케줄러
- CPU 와 메모리 사이의 스케줄링을 담당
- Ready Queue 에 존재하는 프로세스 중 어떤 프로세스를 running 시킬지 결정 
- 프로세스에 CPU 를 할당 (Scheduler dispatch)
- 프로세스의 상태 (ready -> running -> wating -> ready)


#### 중기 스케줄러
- 여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫒아냄
- 프로세스에게서 memory deallocate 
- degree of MultiProgramming 제어 
- 현 시스템에서 메모리에 너무 많은 프로그램이 동시에 올라가는 것을 조절하는 스케줄러
- 프로세스의 상태 (ready -> suspended)

Suspended(stopped): 외부적인 이유로 프로세스의 수행이 정지된 상태로 메모리에서 내려간 상태를 의미한다. 프로세스 전부 디스크로 swap out 된다.
blocked 상태는 다른 I/O 작업을 기다리는 상태이기 때문에 스스로 ready state 로 돌아갈 수 있지만 이 상태는 외부적인 이유로 suspending 되었기 때문에 스스로 돌아갈 수 없다.



### 프로세스 동기화
#### Critial Section (임계영역)
멀티 스레딩에 문제점에서 나오듯, 동일한 자원을 동시에 접근하려는 작업 (공유하려는 변수, 동일 파일) 을 실행하는 코드 영역을 Critical section 이라 칭한다.

### Critical Section Problem (임계영역 문제)
프로세스들이 Critical Section 을 함께 사용할 수 있는 프로토콜을 설계하는 것이다. 

##### Requirements (해결을 위한 기본 조건)
- Mutual Exclusion (상호 배제)
	- 프로세스 p1 이 Critical Section 에서 실핼중이면, 다른 프로세스들은 그들이 가진 Critical Section 에서 실핼될 수 없다.
- Progress (진행))
	- Critical Section 에서 실행중인 프로세스가 없고, 별도의 동작이 없는 프로세스들만 Critical Section 진입 후보로 참여될 수 있다.
- Bounded Wating (한정된 대기)
	- p1 Critical Section 에 진입 신청 후부터 받아들여질때까지, 다른 프로세스들이 Critical Section 에 진입하는 횟수는 제한이 있어야 한다.

#### 해결책 
#### Mutex Lock
- 동시에 공유 자원에 접근하는 것을 막기 위해 Critical Section 에 진입하는 프로세스는 Lock 을 획득하고 Critical Section 을 빠져나올때, Lock 을 방출함으로써 동시에 접근이 되지 않도록 한다. 

### 한계
- 다중처리기 환경에서는 시간적인 효율성 측면에서 적용할 수 없다. 


#### Semaphores 
- 소프트웨어상에서 Critical Section 문제를 해결하기 위한 동기화 동구 


#### 종류 
OS 는 Couting/Binary 세마포를 구분한다
- 카운팅 세마포
	- 가용한 개수를 가진 자원에 대한 접근 제어용으로 사용되며, 세마포는 그 가용한 자원의 개수로 초기화 된다. 자원을 사용하면 세마포가 감소, 방출하면 세마포가 증가한다. 
- 이진 세마포
	- Mutex 라고도 부르며 상호배제의 머리 글자를 따서 만들어졌다. 이름 그래돌 0 과 1 사이의 값만 가능하며, 다중 프로세스들 사이의 Critical Section 문제를 해결하기 위해 사용한다. 

단점 
- Busy Wating (바쁜 대기)
	- spin lock 이라고 불리는 semaphore 초기 버전에서 Critical Section 에 진입해야하는 프로세스는 진입 코드를 계속 반복 실행해야하며, CPU 시간을 낭비했었다. 이를 busy wating 이라고 부르며 특수한 상황이 아니면 비효율적이다.
	- 일반적으로 Semaphore 에서 Critical Section 에 진입을 시도했지만 실패한 프로세스에 대해 Block 시킨 뒤, Critical Section 에 자리가 날 때 다시 깨우는 방식을 사용한다. 이 경우 Busy Wating 으로 인한 시간낭비 문제가 해결된다.
- 
